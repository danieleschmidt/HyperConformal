# Enterprise Encryption and Secrets Management
# End-to-end encryption with HashiCorp Vault integration

apiVersion: v1
kind: Namespace
metadata:
  name: hyperconformal-vault
  labels:
    name: hyperconformal-vault
    encryption: enterprise-grade

---
# HashiCorp Vault for Secrets Management
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: vault
  namespace: hyperconformal-vault
spec:
  serviceName: vault
  replicas: 3
  selector:
    matchLabels:
      app: vault
  template:
    metadata:
      labels:
        app: vault
    spec:
      securityContext:
        runAsNonRoot: true
        runAsUser: 100
        runAsGroup: 1000
        fsGroup: 1000
      containers:
      - name: vault
        image: vault:1.14.0
        command: ["/bin/sh"]
        args:
        - -c
        - |
          vault server -config=/vault/config/vault.hcl
        env:
        - name: VAULT_ADDR
          value: "https://127.0.0.1:8200"
        - name: VAULT_API_ADDR
          value: "https://vault:8200"
        - name: VAULT_CLUSTER_ADDR
          value: "https://vault:8201"
        - name: VAULT_RAFT_NODE_ID
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        ports:
        - containerPort: 8200
          name: vault-port
          protocol: TCP
        - containerPort: 8201
          name: cluster-port
          protocol: TCP
        resources:
          requests:
            memory: "1Gi"
            cpu: "500m"
          limits:
            memory: "2Gi"
            cpu: "1000m"
        securityContext:
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
          capabilities:
            drop:
            - ALL
            add:
            - IPC_LOCK
        volumeMounts:
        - name: vault-config
          mountPath: /vault/config
        - name: vault-storage
          mountPath: /vault/data
        - name: vault-tls
          mountPath: /vault/tls
        readinessProbe:
          httpGet:
            path: /v1/sys/health?standbyok=true
            port: 8200
            scheme: HTTPS
          initialDelaySeconds: 10
          periodSeconds: 10
        livenessProbe:
          httpGet:
            path: /v1/sys/health?standbyok=true
            port: 8200
            scheme: HTTPS
          initialDelaySeconds: 60
          periodSeconds: 30
      volumes:
      - name: vault-config
        configMap:
          name: vault-config
      - name: vault-tls
        secret:
          secretName: vault-tls-secret
  volumeClaimTemplates:
  - metadata:
      name: vault-storage
    spec:
      accessModes: ["ReadWriteOnce"]
      storageClassName: gp3-encrypted
      resources:
        requests:
          storage: 10Gi

---
# Vault Configuration
apiVersion: v1
kind: ConfigMap
metadata:
  name: vault-config
  namespace: hyperconformal-vault
data:
  vault.hcl: |
    ui = true
    api_addr = "https://vault:8200"
    cluster_addr = "https://vault:8201"
    
    storage "raft" {
      path = "/vault/data"
      node_id = "$VAULT_RAFT_NODE_ID"
      
      retry_join {
        leader_api_addr = "https://vault-0.vault:8200"
      }
      retry_join {
        leader_api_addr = "https://vault-1.vault:8200"
      }
      retry_join {
        leader_api_addr = "https://vault-2.vault:8200"
      }
    }
    
    listener "tcp" {
      address = "0.0.0.0:8200"
      tls_cert_file = "/vault/tls/tls.crt"
      tls_key_file = "/vault/tls/tls.key"
      tls_min_version = "tls12"
      tls_cipher_suites = "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384"
    }
    
    seal "awskms" {
      region = "us-east-1"
      kms_key_id = "your-kms-key-id"
    }
    
    telemetry {
      prometheus_retention_time = "30s"
      disable_hostname = true
    }
    
    log_level = "INFO"
    log_format = "json"

---
# Vault Service
apiVersion: v1
kind: Service
metadata:
  name: vault
  namespace: hyperconformal-vault
  labels:
    app: vault
spec:
  type: ClusterIP
  ports:
  - name: vault-port
    port: 8200
    targetPort: 8200
    protocol: TCP
  - name: cluster-port
    port: 8201
    targetPort: 8201
    protocol: TCP
  selector:
    app: vault

---
# Vault Headless Service for StatefulSet
apiVersion: v1
kind: Service
metadata:
  name: vault-headless
  namespace: hyperconformal-vault
  labels:
    app: vault
spec:
  clusterIP: None
  ports:
  - name: vault-port
    port: 8200
    targetPort: 8200
    protocol: TCP
  - name: cluster-port
    port: 8201
    targetPort: 8201
    protocol: TCP
  selector:
    app: vault

---
# Vault TLS Secret (would be generated by cert-manager)
apiVersion: v1
kind: Secret
metadata:
  name: vault-tls-secret
  namespace: hyperconformal-vault
type: kubernetes.io/tls
data:
  tls.crt: LS0tLS1CRUdJTi...  # Base64 encoded certificate
  tls.key: LS0tLS1CRUdJTi...  # Base64 encoded private key

---
# Vault ServiceAccount and RBAC
apiVersion: v1
kind: ServiceAccount
metadata:
  name: vault
  namespace: hyperconformal-vault
  annotations:
    eks.amazonaws.com/role-arn: "arn:aws:iam::ACCOUNT-ID:role/vault-kms-role"

---
# External Secrets Operator for Vault Integration
apiVersion: apps/v1
kind: Deployment
metadata:
  name: external-secrets-operator
  namespace: hyperconformal-vault
spec:
  replicas: 2
  selector:
    matchLabels:
      app: external-secrets-operator
  template:
    metadata:
      labels:
        app: external-secrets-operator
    spec:
      serviceAccountName: external-secrets-operator
      securityContext:
        runAsNonRoot: true
        runAsUser: 65532
        runAsGroup: 65532
        fsGroup: 65532
      containers:
      - name: external-secrets
        image: ghcr.io/external-secrets/external-secrets:v0.9.0
        args:
        - --metrics-addr=:8080
        - --enable-leader-election
        - --leader-election-id=external-secrets-controller
        ports:
        - containerPort: 8080
          name: metrics
        resources:
          requests:
            memory: "256Mi"
            cpu: "100m"
          limits:
            memory: "512Mi"
            cpu: "200m"
        securityContext:
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
          capabilities:
            drop:
            - ALL

---
# External Secrets ServiceAccount
apiVersion: v1
kind: ServiceAccount
metadata:
  name: external-secrets-operator
  namespace: hyperconformal-vault

---
# External Secrets RBAC
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: external-secrets-operator
rules:
- apiGroups: [""]
  resources: ["secrets"]
  verbs: ["create", "update", "delete", "get", "list", "watch"]
- apiGroups: ["external-secrets.io"]
  resources: ["*"]
  verbs: ["*"]

---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: external-secrets-operator
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: external-secrets-operator
subjects:
- kind: ServiceAccount
  name: external-secrets-operator
  namespace: hyperconformal-vault

---
# Vault SecretStore Configuration
apiVersion: external-secrets.io/v1beta1
kind: SecretStore
metadata:
  name: vault-backend
  namespace: hyperconformal-production
spec:
  provider:
    vault:
      server: "https://vault.hyperconformal-vault.svc.cluster.local:8200"
      path: "secret"
      version: "v2"
      auth:
        kubernetes:
          mountPath: "kubernetes"
          role: "hyperconformal-role"
          serviceAccountRef:
            name: "hyperconformal-sa"

---
# External Secret for Database Credentials
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: database-credentials
  namespace: hyperconformal-production
spec:
  refreshInterval: 1m
  secretStoreRef:
    name: vault-backend
    kind: SecretStore
  target:
    name: hyperconformal-db-secret
    creationPolicy: Owner
  data:
  - secretKey: username
    remoteRef:
      key: database/credentials
      property: username
  - secretKey: password
    remoteRef:
      key: database/credentials
      property: password
  - secretKey: connection-string
    remoteRef:
      key: database/credentials
      property: connection-string

---
# External Secret for API Keys
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: api-keys
  namespace: hyperconformal-production
spec:
  refreshInterval: 5m
  secretStoreRef:
    name: vault-backend
    kind: SecretStore
  target:
    name: hyperconformal-api-keys
    creationPolicy: Owner
  data:
  - secretKey: encryption-key
    remoteRef:
      key: api/keys
      property: encryption-key
  - secretKey: signing-key
    remoteRef:
      key: api/keys
      property: signing-key
  - secretKey: jwt-secret
    remoteRef:
      key: api/keys
      property: jwt-secret

---
# Encryption Key Rotation Job
apiVersion: batch/v1
kind: CronJob
metadata:
  name: key-rotation
  namespace: hyperconformal-vault
spec:
  schedule: "0 2 * * 0"  # Weekly on Sunday at 2 AM
  jobTemplate:
    spec:
      template:
        spec:
          serviceAccountName: vault
          containers:
          - name: key-rotator
            image: vault:1.14.0
            command: ["/bin/sh"]
            args:
            - -c
            - |
              export VAULT_ADDR=https://vault:8200
              export VAULT_TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
              
              # Rotate database credentials
              vault kv put secret/database/credentials \
                username="hyperconformal_$(date +%s)" \
                password="$(openssl rand -base64 32)" \
                connection-string="postgresql://..."
              
              # Rotate API keys
              vault kv put secret/api/keys \
                encryption-key="$(openssl rand -base64 32)" \
                signing-key="$(openssl rand -base64 64)" \
                jwt-secret="$(openssl rand -base64 32)"
              
              echo "Key rotation completed successfully"
            env:
            - name: VAULT_SKIP_VERIFY
              value: "true"
            resources:
              requests:
                memory: "128Mi"
                cpu: "100m"
              limits:
                memory: "256Mi"
                cpu: "200m"
            securityContext:
              allowPrivilegeEscalation: false
              readOnlyRootFilesystem: true
              runAsNonRoot: true
              runAsUser: 100
              capabilities:
                drop:
                - ALL
          restartPolicy: OnFailure

---
# Data Encryption at Rest using Sealed Secrets
apiVersion: v1
kind: Secret
metadata:
  name: sealed-secrets-controller-key
  namespace: kube-system
type: kubernetes.io/tls
data:
  tls.crt: LS0tLS1CRUdJTi...  # Base64 encoded certificate
  tls.key: LS0tLS1CRUdJTi...  # Base64 encoded private key

---
# Sealed Secrets Controller
apiVersion: apps/v1
kind: Deployment
metadata:
  name: sealed-secrets-controller
  namespace: kube-system
spec:
  replicas: 1
  selector:
    matchLabels:
      name: sealed-secrets-controller
  template:
    metadata:
      labels:
        name: sealed-secrets-controller
    spec:
      serviceAccountName: sealed-secrets-controller
      securityContext:
        runAsNonRoot: true
        runAsUser: 1001
        fsGroup: 65534
      containers:
      - name: sealed-secrets-controller
        image: quay.io/bitnami/sealed-secrets-controller:v0.22.0
        command:
        - controller
        args:
        - --key-prefix=hyperconformal
        - --key-size=4096
        - --my-version=v0.22.0
        ports:
        - containerPort: 8080
          name: http
        resources:
          requests:
            memory: "256Mi"
            cpu: "100m"
          limits:
            memory: "512Mi"
            cpu: "200m"
        securityContext:
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
          capabilities:
            drop:
            - ALL
        volumeMounts:
        - name: tmp
          mountPath: /tmp
      volumes:
      - name: tmp
        emptyDir: {}

---
# Sealed Secrets ServiceAccount
apiVersion: v1
kind: ServiceAccount
metadata:
  name: sealed-secrets-controller
  namespace: kube-system

---
# Sealed Secrets RBAC
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: sealed-secrets-controller
rules:
- apiGroups: [""]
  resources: ["secrets"]
  verbs: ["create", "update", "delete", "get", "list", "watch"]
- apiGroups: ["bitnami.com"]
  resources: ["sealedsecrets"]
  verbs: ["get", "list", "watch", "update"]
- apiGroups: [""]
  resources: ["events"]
  verbs: ["create", "patch"]

---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: sealed-secrets-controller
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: sealed-secrets-controller
subjects:
- kind: ServiceAccount
  name: sealed-secrets-controller
  namespace: kube-system

---
# Certificate Authority for Internal mTLS
apiVersion: v1
kind: Secret
metadata:
  name: hyperconformal-internal-ca
  namespace: hyperconformal-production
type: kubernetes.io/tls
data:
  tls.crt: LS0tLS1CRUdJTi...  # Internal CA certificate
  tls.key: LS0tLS1CRUdJTi...  # Internal CA private key

---
# TLS Certificate for Service Mesh
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: hyperconformal-service-cert
  namespace: hyperconformal-production
spec:
  secretName: hyperconformal-service-tls
  issuerRef:
    name: hyperconformal-internal-ca-issuer
    kind: ClusterIssuer
  commonName: hyperconformal.local
  dnsNames:
  - hyperconformal.local
  - hyperconformal-production.hyperconformal.local
  - "*.hyperconformal-production.svc.cluster.local"
  duration: 8760h  # 1 year
  renewBefore: 720h  # 30 days

---
# Cluster Issuer for Internal Certificates
apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  name: hyperconformal-internal-ca-issuer
spec:
  ca:
    secretName: hyperconformal-internal-ca

---
# Network Encryption Policy
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: require-tls-encryption
  namespace: hyperconformal-production
spec:
  podSelector:
    matchLabels:
      app: hyperconformal
  policyTypes:
  - Ingress
  - Egress
  ingress:
  - from:
    - podSelector:
        matchLabels:
          encryption: required
    ports:
    - protocol: TCP
      port: 8443  # HTTPS only
  egress:
  - to:
    - podSelector:
        matchLabels:
          encryption: required
    ports:
    - protocol: TCP
      port: 8443  # HTTPS only
  - to: []  # Allow DNS
    ports:
    - protocol: UDP
      port: 53

---
# Encryption Monitoring and Compliance
apiVersion: v1
kind: ConfigMap
metadata:
  name: encryption-compliance-check
  namespace: hyperconformal-security
data:
  check-encryption.sh: |
    #!/bin/bash
    
    echo "=== HyperConformal Encryption Compliance Check ==="
    
    # Check if all secrets are encrypted
    kubectl get secrets --all-namespaces -o json | \
      jq -r '.items[] | select(.type != "kubernetes.io/service-account-token") | "\(.metadata.namespace)/\(.metadata.name)"' | \
      while read secret; do
        echo "Checking encryption for secret: $secret"
        # Verify encryption at rest
      done
    
    # Check TLS certificates
    kubectl get certificates --all-namespaces -o json | \
      jq -r '.items[] | "\(.metadata.namespace)/\(.metadata.name): \(.status.conditions[0].status)"'
    
    # Verify mTLS is enabled
    kubectl get peerauthentication --all-namespaces -o json | \
      jq -r '.items[] | "\(.metadata.namespace)/\(.metadata.name): \(.spec.mtls.mode)"'
    
    echo "=== Compliance Check Complete ==="

---
# Encryption Status CronJob
apiVersion: batch/v1
kind: CronJob
metadata:
  name: encryption-compliance-check
  namespace: hyperconformal-security
spec:
  schedule: "0 */6 * * *"  # Every 6 hours
  jobTemplate:
    spec:
      template:
        spec:
          serviceAccountName: encryption-checker
          containers:
          - name: compliance-checker
            image: bitnami/kubectl:latest
            command: ["/bin/bash", "/scripts/check-encryption.sh"]
            resources:
              requests:
                memory: "128Mi"
                cpu: "100m"
              limits:
                memory: "256Mi"
                cpu: "200m"
            securityContext:
              allowPrivilegeEscalation: false
              readOnlyRootFilesystem: true
              runAsNonRoot: true
              runAsUser: 65534
              capabilities:
                drop:
                - ALL
            volumeMounts:
            - name: scripts
              mountPath: /scripts
          volumes:
          - name: scripts
            configMap:
              name: encryption-compliance-check
              defaultMode: 0755
          restartPolicy: OnFailure

---
# ServiceAccount for Encryption Checker
apiVersion: v1
kind: ServiceAccount
metadata:
  name: encryption-checker
  namespace: hyperconformal-security

---
# RBAC for Encryption Checker
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: encryption-checker
rules:
- apiGroups: [""]
  resources: ["secrets"]
  verbs: ["get", "list"]
- apiGroups: ["cert-manager.io"]
  resources: ["certificates"]
  verbs: ["get", "list"]
- apiGroups: ["security.istio.io"]
  resources: ["peerauthentications"]
  verbs: ["get", "list"]

---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: encryption-checker
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: encryption-checker
subjects:
- kind: ServiceAccount
  name: encryption-checker
  namespace: hyperconformal-security